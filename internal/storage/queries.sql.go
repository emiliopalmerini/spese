// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package storage

import (
	"context"
	"database/sql"
	"time"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (date, description, amount_cents, primary_category, secondary_category)
VALUES (date(?), ?, ?, ?, ?)
RETURNING id, date, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status
`

type CreateExpenseParams struct {
	Date              interface{} `db:"date" json:"date"`
	Description       string      `db:"description" json:"description"`
	AmountCents       int64       `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string      `db:"primary_category" json:"primary_category"`
	SecondaryCategory string      `db:"secondary_category" json:"secondary_category"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.Date,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const createPrimaryCategory = `-- name: CreatePrimaryCategory :one
INSERT INTO primary_categories (name)
VALUES (?)
RETURNING id, name, created_at
`

func (q *Queries) CreatePrimaryCategory(ctx context.Context, name string) (PrimaryCategory, error) {
	row := q.db.QueryRowContext(ctx, createPrimaryCategory, name)
	var i PrimaryCategory
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const createRecurrentExpense = `-- name: CreateRecurrentExpense :one
INSERT INTO recurrent_expenses (
    start_date, end_date, repetition_type, description, 
    amount_cents, primary_category, secondary_category
)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, created_at, updated_at
`

type CreateRecurrentExpenseParams struct {
	StartDate         time.Time   `db:"start_date" json:"start_date"`
	EndDate           interface{} `db:"end_date" json:"end_date"`
	RepetitionType    string      `db:"repetition_type" json:"repetition_type"`
	Description       string      `db:"description" json:"description"`
	AmountCents       int64       `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string      `db:"primary_category" json:"primary_category"`
	SecondaryCategory string      `db:"secondary_category" json:"secondary_category"`
}

// Recurrent Expenses queries
func (q *Queries) CreateRecurrentExpense(ctx context.Context, arg CreateRecurrentExpenseParams) (RecurrentExpense, error) {
	row := q.db.QueryRowContext(ctx, createRecurrentExpense,
		arg.StartDate,
		arg.EndDate,
		arg.RepetitionType,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
	)
	var i RecurrentExpense
	err := row.Scan(
		&i.ID,
		&i.StartDate,
		&i.EndDate,
		&i.RepetitionType,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSecondaryCategory = `-- name: CreateSecondaryCategory :one
INSERT INTO secondary_categories (name, primary_category_id)
VALUES (?, ?)
RETURNING id, name, primary_category_id, created_at
`

type CreateSecondaryCategoryParams struct {
	Name              string `db:"name" json:"name"`
	PrimaryCategoryID int64  `db:"primary_category_id" json:"primary_category_id"`
}

func (q *Queries) CreateSecondaryCategory(ctx context.Context, arg CreateSecondaryCategoryParams) (SecondaryCategory, error) {
	row := q.db.QueryRowContext(ctx, createSecondaryCategory, arg.Name, arg.PrimaryCategoryID)
	var i SecondaryCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PrimaryCategoryID,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateRecurrentExpense = `-- name: DeactivateRecurrentExpense :exec
UPDATE recurrent_expenses
SET is_active = 0,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) DeactivateRecurrentExpense(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deactivateRecurrentExpense, id)
	return err
}

const deletePrimaryCategory = `-- name: DeletePrimaryCategory :exec
DELETE FROM primary_categories WHERE name = ?
`

func (q *Queries) DeletePrimaryCategory(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deletePrimaryCategory, name)
	return err
}

const deleteRecurrentExpense = `-- name: DeleteRecurrentExpense :exec
DELETE FROM recurrent_expenses
WHERE id = ?
`

func (q *Queries) DeleteRecurrentExpense(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRecurrentExpense, id)
	return err
}

const deleteSecondaryCategory = `-- name: DeleteSecondaryCategory :exec
DELETE FROM secondary_categories WHERE name = ?
`

func (q *Queries) DeleteSecondaryCategory(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteSecondaryCategory, name)
	return err
}

const getActiveRecurrentExpensesByDate = `-- name: GetActiveRecurrentExpensesByDate :many
SELECT id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, created_at, updated_at FROM recurrent_expenses
WHERE is_active = 1
  AND start_date <= ?
  AND (end_date IS NULL OR end_date >= ?)
ORDER BY start_date DESC
`

type GetActiveRecurrentExpensesByDateParams struct {
	StartDate time.Time   `db:"start_date" json:"start_date"`
	EndDate   interface{} `db:"end_date" json:"end_date"`
}

func (q *Queries) GetActiveRecurrentExpensesByDate(ctx context.Context, arg GetActiveRecurrentExpensesByDateParams) ([]RecurrentExpense, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRecurrentExpensesByDate, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurrentExpense
	for rows.Next() {
		var i RecurrentExpense
		if err := rows.Scan(
			&i.ID,
			&i.StartDate,
			&i.EndDate,
			&i.RepetitionType,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategorySums = `-- name: GetCategorySums :many
SELECT primary_category, CAST(SUM(amount_cents) AS INTEGER) as total_amount
FROM expenses 
WHERE strftime('%m', date) = printf('%02d', ?) AND deleted_at IS NULL
GROUP BY primary_category
ORDER BY total_amount DESC
`

type GetCategorySumsRow struct {
	PrimaryCategory string `db:"primary_category" json:"primary_category"`
	TotalAmount     int64  `db:"total_amount" json:"total_amount"`
}

func (q *Queries) GetCategorySums(ctx context.Context, printf interface{}) ([]GetCategorySumsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategorySums, printf)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategorySumsRow
	for rows.Next() {
		var i GetCategorySumsRow
		if err := rows.Scan(&i.PrimaryCategory, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpense = `-- name: GetExpense :one
SELECT id, date, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) GetExpense(ctx context.Context, id int64) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpense, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const getExpensesByMonth = `-- name: GetExpensesByMonth :many
SELECT id, date, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses 
WHERE strftime('%m', date) = printf('%02d', ?) AND deleted_at IS NULL
ORDER BY date DESC, created_at DESC
`

func (q *Queries) GetExpensesByMonth(ctx context.Context, printf interface{}) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByMonth, printf)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.Version,
			&i.CreatedAt,
			&i.SyncedAt,
			&i.SyncStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTotal = `-- name: GetMonthTotal :one
SELECT CAST(COALESCE(SUM(amount_cents), 0) AS INTEGER) as total
FROM expenses 
WHERE strftime('%m', date) = printf('%02d', ?) AND deleted_at IS NULL
`

func (q *Queries) GetMonthTotal(ctx context.Context, printf interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMonthTotal, printf)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getPendingSyncExpenses = `-- name: GetPendingSyncExpenses :many
SELECT id, version, created_at FROM expenses 
WHERE sync_status = 'pending' AND deleted_at IS NULL
ORDER BY created_at ASC
LIMIT ?
`

type GetPendingSyncExpensesRow struct {
	ID        int64        `db:"id" json:"id"`
	Version   int64        `db:"version" json:"version"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
}

func (q *Queries) GetPendingSyncExpenses(ctx context.Context, limit int64) ([]GetPendingSyncExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSyncExpenses, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingSyncExpensesRow
	for rows.Next() {
		var i GetPendingSyncExpensesRow
		if err := rows.Scan(&i.ID, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryCategories = `-- name: GetPrimaryCategories :many
SELECT name FROM primary_categories 
ORDER BY name ASC
`

// Primary Categories queries
func (q *Queries) GetPrimaryCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getPrimaryCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurrentExpenseByID = `-- name: GetRecurrentExpenseByID :one
SELECT id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, created_at, updated_at FROM recurrent_expenses
WHERE id = ?
`

func (q *Queries) GetRecurrentExpenseByID(ctx context.Context, id int64) (RecurrentExpense, error) {
	row := q.db.QueryRowContext(ctx, getRecurrentExpenseByID, id)
	var i RecurrentExpense
	err := row.Scan(
		&i.ID,
		&i.StartDate,
		&i.EndDate,
		&i.RepetitionType,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecurrentExpenses = `-- name: GetRecurrentExpenses :many
SELECT id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, created_at, updated_at FROM recurrent_expenses
WHERE is_active = 1
ORDER BY start_date DESC
`

func (q *Queries) GetRecurrentExpenses(ctx context.Context) ([]RecurrentExpense, error) {
	rows, err := q.db.QueryContext(ctx, getRecurrentExpenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurrentExpense
	for rows.Next() {
		var i RecurrentExpense
		if err := rows.Scan(
			&i.ID,
			&i.StartDate,
			&i.EndDate,
			&i.RepetitionType,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecondariesByPrimary = `-- name: GetSecondariesByPrimary :many
SELECT sc.name FROM secondary_categories sc
JOIN primary_categories pc ON sc.primary_category_id = pc.id
WHERE pc.name = ?
ORDER BY sc.name ASC
`

func (q *Queries) GetSecondariesByPrimary(ctx context.Context, name string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSecondariesByPrimary, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecondaryCategories = `-- name: GetSecondaryCategories :many
SELECT name FROM secondary_categories 
ORDER BY name ASC
`

// Secondary Categories queries
func (q *Queries) GetSecondaryCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSecondaryCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markExpenseSyncError = `-- name: MarkExpenseSyncError :exec
UPDATE expenses 
SET sync_status = 'error'
WHERE id = ?
`

func (q *Queries) MarkExpenseSyncError(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSyncError, id)
	return err
}

const markExpenseSynced = `-- name: MarkExpenseSynced :exec
UPDATE expenses 
SET sync_status = 'synced', synced_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkExpenseSynced(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSynced, id)
	return err
}

const refreshCategories = `-- name: RefreshCategories :exec
DELETE FROM secondary_categories
`

func (q *Queries) RefreshCategories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshCategories)
	return err
}

const refreshPrimaryCategories = `-- name: RefreshPrimaryCategories :exec
DELETE FROM primary_categories
`

func (q *Queries) RefreshPrimaryCategories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshPrimaryCategories)
	return err
}

const softDeleteExpense = `-- name: SoftDeleteExpense :exec
UPDATE expenses 
SET deleted_at = CURRENT_TIMESTAMP 
WHERE id = ? AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteExpense(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, softDeleteExpense, id)
	return err
}

const updateRecurrentExpense = `-- name: UpdateRecurrentExpense :exec
UPDATE recurrent_expenses
SET start_date = ?, 
    end_date = ?, 
    repetition_type = ?, 
    description = ?,
    amount_cents = ?, 
    primary_category = ?, 
    secondary_category = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateRecurrentExpenseParams struct {
	StartDate         time.Time   `db:"start_date" json:"start_date"`
	EndDate           interface{} `db:"end_date" json:"end_date"`
	RepetitionType    string      `db:"repetition_type" json:"repetition_type"`
	Description       string      `db:"description" json:"description"`
	AmountCents       int64       `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string      `db:"primary_category" json:"primary_category"`
	SecondaryCategory string      `db:"secondary_category" json:"secondary_category"`
	ID                int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateRecurrentExpense(ctx context.Context, arg UpdateRecurrentExpenseParams) error {
	_, err := q.db.ExecContext(ctx, updateRecurrentExpense,
		arg.StartDate,
		arg.EndDate,
		arg.RepetitionType,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
		arg.ID,
	)
	return err
}
