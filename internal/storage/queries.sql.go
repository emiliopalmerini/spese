// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package storage

import (
	"context"
	"database/sql"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (day, month, description, amount_cents, primary_category, secondary_category)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status
`

type CreateExpenseParams struct {
	Day               int64  `db:"day" json:"day"`
	Month             int64  `db:"month" json:"month"`
	Description       string `db:"description" json:"description"`
	AmountCents       int64  `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string `db:"primary_category" json:"primary_category"`
	SecondaryCategory string `db:"secondary_category" json:"secondary_category"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.Day,
		arg.Month,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Day,
		&i.Month,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const getCategorySums = `-- name: GetCategorySums :many
SELECT primary_category, CAST(SUM(amount_cents) AS INTEGER) as total_amount
FROM expenses 
WHERE month = ?
GROUP BY primary_category
ORDER BY total_amount DESC
`

type GetCategorySumsRow struct {
	PrimaryCategory string `db:"primary_category" json:"primary_category"`
	TotalAmount     int64  `db:"total_amount" json:"total_amount"`
}

func (q *Queries) GetCategorySums(ctx context.Context, month int64) ([]GetCategorySumsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategorySums, month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategorySumsRow
	for rows.Next() {
		var i GetCategorySumsRow
		if err := rows.Scan(&i.PrimaryCategory, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpense = `-- name: GetExpense :one
SELECT id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses WHERE id = ?
`

func (q *Queries) GetExpense(ctx context.Context, id int64) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpense, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Day,
		&i.Month,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const getExpensesByMonth = `-- name: GetExpensesByMonth :many
SELECT id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses 
WHERE month = ?
ORDER BY day DESC, created_at DESC
`

func (q *Queries) GetExpensesByMonth(ctx context.Context, month int64) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByMonth, month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Day,
			&i.Month,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.Version,
			&i.CreatedAt,
			&i.SyncedAt,
			&i.SyncStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTotal = `-- name: GetMonthTotal :one
SELECT CAST(COALESCE(SUM(amount_cents), 0) AS INTEGER) as total
FROM expenses 
WHERE month = ?
`

func (q *Queries) GetMonthTotal(ctx context.Context, month int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMonthTotal, month)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getPendingSyncExpenses = `-- name: GetPendingSyncExpenses :many
SELECT id, version, created_at FROM expenses 
WHERE sync_status = 'pending'
ORDER BY created_at ASC
LIMIT ?
`

type GetPendingSyncExpensesRow struct {
	ID        int64        `db:"id" json:"id"`
	Version   int64        `db:"version" json:"version"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
}

func (q *Queries) GetPendingSyncExpenses(ctx context.Context, limit int64) ([]GetPendingSyncExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSyncExpenses, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingSyncExpensesRow
	for rows.Next() {
		var i GetPendingSyncExpensesRow
		if err := rows.Scan(&i.ID, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markExpenseSyncError = `-- name: MarkExpenseSyncError :exec
UPDATE expenses 
SET sync_status = 'error'
WHERE id = ?
`

func (q *Queries) MarkExpenseSyncError(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSyncError, id)
	return err
}

const markExpenseSynced = `-- name: MarkExpenseSynced :exec
UPDATE expenses 
SET sync_status = 'synced', synced_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkExpenseSynced(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSynced, id)
	return err
}
