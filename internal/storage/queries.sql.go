// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package storage

import (
	"context"
	"database/sql"
)

const clearCategoriesByType = `-- name: ClearCategoriesByType :exec
DELETE FROM categories WHERE type = ?
`

func (q *Queries) ClearCategoriesByType(ctx context.Context, type_ string) error {
	_, err := q.db.ExecContext(ctx, clearCategoriesByType, type_)
	return err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, type)
VALUES (?, ?)
RETURNING id, name, type, created_at
`

type CreateCategoryParams struct {
	Name string `db:"name" json:"name"`
	Type string `db:"type" json:"type"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, createCategory, arg.Name, arg.Type)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (day, month, description, amount_cents, primary_category, secondary_category)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status
`

type CreateExpenseParams struct {
	Day               int64  `db:"day" json:"day"`
	Month             int64  `db:"month" json:"month"`
	Description       string `db:"description" json:"description"`
	AmountCents       int64  `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string `db:"primary_category" json:"primary_category"`
	SecondaryCategory string `db:"secondary_category" json:"secondary_category"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.Day,
		arg.Month,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Day,
		&i.Month,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE name = ? AND type = ?
`

type DeleteCategoryParams struct {
	Name string `db:"name" json:"name"`
	Type string `db:"type" json:"type"`
}

func (q *Queries) DeleteCategory(ctx context.Context, arg DeleteCategoryParams) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, arg.Name, arg.Type)
	return err
}

const getCategoriesByType = `-- name: GetCategoriesByType :many
SELECT name FROM categories 
WHERE type = ?
ORDER BY name ASC
`

func (q *Queries) GetCategoriesByType(ctx context.Context, type_ string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCategoriesByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryCount = `-- name: GetCategoryCount :one
SELECT COUNT(*) FROM categories
`

func (q *Queries) GetCategoryCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCategoryCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCategoryLastSync = `-- name: GetCategoryLastSync :one
SELECT MAX(created_at) FROM categories
`

func (q *Queries) GetCategoryLastSync(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getCategoryLastSync)
	var max interface{}
	err := row.Scan(&max)
	return max, err
}

const getCategorySums = `-- name: GetCategorySums :many
SELECT primary_category, CAST(SUM(amount_cents) AS INTEGER) as total_amount
FROM expenses 
WHERE month = ?
GROUP BY primary_category
ORDER BY total_amount DESC
`

type GetCategorySumsRow struct {
	PrimaryCategory string `db:"primary_category" json:"primary_category"`
	TotalAmount     int64  `db:"total_amount" json:"total_amount"`
}

func (q *Queries) GetCategorySums(ctx context.Context, month int64) ([]GetCategorySumsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategorySums, month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategorySumsRow
	for rows.Next() {
		var i GetCategorySumsRow
		if err := rows.Scan(&i.PrimaryCategory, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpense = `-- name: GetExpense :one
SELECT id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses WHERE id = ?
`

func (q *Queries) GetExpense(ctx context.Context, id int64) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpense, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Day,
		&i.Month,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const getExpensesByMonth = `-- name: GetExpensesByMonth :many
SELECT id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses 
WHERE month = ?
ORDER BY day DESC, created_at DESC
`

func (q *Queries) GetExpensesByMonth(ctx context.Context, month int64) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByMonth, month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Day,
			&i.Month,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.Version,
			&i.CreatedAt,
			&i.SyncedAt,
			&i.SyncStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTotal = `-- name: GetMonthTotal :one
SELECT CAST(COALESCE(SUM(amount_cents), 0) AS INTEGER) as total
FROM expenses 
WHERE month = ?
`

func (q *Queries) GetMonthTotal(ctx context.Context, month int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMonthTotal, month)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getPendingSyncExpenses = `-- name: GetPendingSyncExpenses :many
SELECT id, version, created_at FROM expenses 
WHERE sync_status = 'pending'
ORDER BY created_at ASC
LIMIT ?
`

type GetPendingSyncExpensesRow struct {
	ID        int64        `db:"id" json:"id"`
	Version   int64        `db:"version" json:"version"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
}

func (q *Queries) GetPendingSyncExpenses(ctx context.Context, limit int64) ([]GetPendingSyncExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSyncExpenses, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingSyncExpensesRow
	for rows.Next() {
		var i GetPendingSyncExpensesRow
		if err := rows.Scan(&i.ID, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markExpenseSyncError = `-- name: MarkExpenseSyncError :exec
UPDATE expenses 
SET sync_status = 'error'
WHERE id = ?
`

func (q *Queries) MarkExpenseSyncError(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSyncError, id)
	return err
}

const markExpenseSynced = `-- name: MarkExpenseSynced :exec
UPDATE expenses 
SET sync_status = 'synced', synced_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkExpenseSynced(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSynced, id)
	return err
}

const refreshCategories = `-- name: RefreshCategories :exec
DELETE FROM categories
`

func (q *Queries) RefreshCategories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshCategories)
	return err
}

const upsertCategory = `-- name: UpsertCategory :exec
INSERT INTO categories (name, type)
VALUES (?, ?)
ON CONFLICT (name, type) DO NOTHING
`

type UpsertCategoryParams struct {
	Name string `db:"name" json:"name"`
	Type string `db:"type" json:"type"`
}

func (q *Queries) UpsertCategory(ctx context.Context, arg UpsertCategoryParams) error {
	_, err := q.db.ExecContext(ctx, upsertCategory, arg.Name, arg.Type)
	return err
}
