// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package storage

import (
	"context"
	"database/sql"
	"time"
)

const cleanupCompletedSyncs = `-- name: CleanupCompletedSyncs :exec
DELETE FROM sync_queue
WHERE status = 'completed'
  AND processed_at < ?
`

// Removes completed items older than the specified timestamp.
func (q *Queries) CleanupCompletedSyncs(ctx context.Context, processedAt interface{}) error {
	_, err := q.db.ExecContext(ctx, cleanupCompletedSyncs, processedAt)
	return err
}

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (date, description, amount_cents, primary_category, secondary_category)
VALUES (date(?), ?, ?, ?, ?)
RETURNING id, date, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status
`

type CreateExpenseParams struct {
	Date              interface{} `db:"date" json:"date"`
	Description       string      `db:"description" json:"description"`
	AmountCents       int64       `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string      `db:"primary_category" json:"primary_category"`
	SecondaryCategory string      `db:"secondary_category" json:"secondary_category"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.Date,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const createIncome = `-- name: CreateIncome :one
INSERT INTO incomes (date, description, amount_cents, category)
VALUES (date(?), ?, ?, ?)
RETURNING id, date, description, amount_cents, category, version, created_at, synced_at, sync_status
`

type CreateIncomeParams struct {
	Date        interface{} `db:"date" json:"date"`
	Description string      `db:"description" json:"description"`
	AmountCents int64       `db:"amount_cents" json:"amount_cents"`
	Category    string      `db:"category" json:"category"`
}

// Income queries
func (q *Queries) CreateIncome(ctx context.Context, arg CreateIncomeParams) (Income, error) {
	row := q.db.QueryRowContext(ctx, createIncome,
		arg.Date,
		arg.Description,
		arg.AmountCents,
		arg.Category,
	)
	var i Income
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Description,
		&i.AmountCents,
		&i.Category,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const createPrimaryCategory = `-- name: CreatePrimaryCategory :one
INSERT INTO primary_categories (name)
VALUES (?)
RETURNING id, name, created_at
`

func (q *Queries) CreatePrimaryCategory(ctx context.Context, name string) (PrimaryCategory, error) {
	row := q.db.QueryRowContext(ctx, createPrimaryCategory, name)
	var i PrimaryCategory
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const createRecurrentExpense = `-- name: CreateRecurrentExpense :one
INSERT INTO recurrent_expenses (
    start_date, end_date, repetition_type, description, 
    amount_cents, primary_category, secondary_category
)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, last_execution_date, created_at, updated_at
`

type CreateRecurrentExpenseParams struct {
	StartDate         time.Time   `db:"start_date" json:"start_date"`
	EndDate           interface{} `db:"end_date" json:"end_date"`
	RepetitionType    string      `db:"repetition_type" json:"repetition_type"`
	Description       string      `db:"description" json:"description"`
	AmountCents       int64       `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string      `db:"primary_category" json:"primary_category"`
	SecondaryCategory string      `db:"secondary_category" json:"secondary_category"`
}

// Recurrent Expenses queries
func (q *Queries) CreateRecurrentExpense(ctx context.Context, arg CreateRecurrentExpenseParams) (RecurrentExpense, error) {
	row := q.db.QueryRowContext(ctx, createRecurrentExpense,
		arg.StartDate,
		arg.EndDate,
		arg.RepetitionType,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
	)
	var i RecurrentExpense
	err := row.Scan(
		&i.ID,
		&i.StartDate,
		&i.EndDate,
		&i.RepetitionType,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.IsActive,
		&i.LastExecutionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSecondaryCategory = `-- name: CreateSecondaryCategory :one
INSERT INTO secondary_categories (name, primary_category_id)
VALUES (?, ?)
RETURNING id, name, primary_category_id, created_at
`

type CreateSecondaryCategoryParams struct {
	Name              string `db:"name" json:"name"`
	PrimaryCategoryID int64  `db:"primary_category_id" json:"primary_category_id"`
}

func (q *Queries) CreateSecondaryCategory(ctx context.Context, arg CreateSecondaryCategoryParams) (SecondaryCategory, error) {
	row := q.db.QueryRowContext(ctx, createSecondaryCategory, arg.Name, arg.PrimaryCategoryID)
	var i SecondaryCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PrimaryCategoryID,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateRecurrentExpense = `-- name: DeactivateRecurrentExpense :exec
UPDATE recurrent_expenses
SET is_active = 0,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) DeactivateRecurrentExpense(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deactivateRecurrentExpense, id)
	return err
}

const deletePrimaryCategory = `-- name: DeletePrimaryCategory :exec
DELETE FROM primary_categories WHERE name = ?
`

func (q *Queries) DeletePrimaryCategory(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deletePrimaryCategory, name)
	return err
}

const deleteRecurrentExpense = `-- name: DeleteRecurrentExpense :exec
DELETE FROM recurrent_expenses
WHERE id = ?
`

func (q *Queries) DeleteRecurrentExpense(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRecurrentExpense, id)
	return err
}

const deleteSecondaryCategory = `-- name: DeleteSecondaryCategory :exec
DELETE FROM secondary_categories WHERE name = ?
`

func (q *Queries) DeleteSecondaryCategory(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteSecondaryCategory, name)
	return err
}

const dequeueSyncBatch = `-- name: DequeueSyncBatch :many
SELECT id, operation, expense_id, expense_day, expense_month, expense_description, expense_amount_cents, expense_primary, expense_secondary, status, attempts, max_attempts, last_error, created_at, updated_at, processed_at, next_retry_at FROM sync_queue
WHERE status = 'pending'
  AND (next_retry_at IS NULL OR next_retry_at <= CURRENT_TIMESTAMP)
ORDER BY created_at ASC
LIMIT ?
`

// Fetches a batch of pending items ready for processing.
func (q *Queries) DequeueSyncBatch(ctx context.Context, limit int64) ([]SyncQueue, error) {
	rows, err := q.db.QueryContext(ctx, dequeueSyncBatch, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SyncQueue
	for rows.Next() {
		var i SyncQueue
		if err := rows.Scan(
			&i.ID,
			&i.Operation,
			&i.ExpenseID,
			&i.ExpenseDay,
			&i.ExpenseMonth,
			&i.ExpenseDescription,
			&i.ExpenseAmountCents,
			&i.ExpensePrimary,
			&i.ExpenseSecondary,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProcessedAt,
			&i.NextRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const enqueueDelete = `-- name: EnqueueDelete :one
INSERT INTO sync_queue (
    operation, expense_id, status,
    expense_day, expense_month, expense_description,
    expense_amount_cents, expense_primary, expense_secondary,
    created_at, updated_at
)
VALUES ('delete', ?, 'pending', ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, operation, expense_id, expense_day, expense_month, expense_description, expense_amount_cents, expense_primary, expense_secondary, status, attempts, max_attempts, last_error, created_at, updated_at, processed_at, next_retry_at
`

type EnqueueDeleteParams struct {
	ExpenseID          int64       `db:"expense_id" json:"expense_id"`
	ExpenseDay         interface{} `db:"expense_day" json:"expense_day"`
	ExpenseMonth       interface{} `db:"expense_month" json:"expense_month"`
	ExpenseDescription interface{} `db:"expense_description" json:"expense_description"`
	ExpenseAmountCents interface{} `db:"expense_amount_cents" json:"expense_amount_cents"`
	ExpensePrimary     interface{} `db:"expense_primary" json:"expense_primary"`
	ExpenseSecondary   interface{} `db:"expense_secondary" json:"expense_secondary"`
}

// Enqueues a delete operation with full expense data.
func (q *Queries) EnqueueDelete(ctx context.Context, arg EnqueueDeleteParams) (SyncQueue, error) {
	row := q.db.QueryRowContext(ctx, enqueueDelete,
		arg.ExpenseID,
		arg.ExpenseDay,
		arg.ExpenseMonth,
		arg.ExpenseDescription,
		arg.ExpenseAmountCents,
		arg.ExpensePrimary,
		arg.ExpenseSecondary,
	)
	var i SyncQueue
	err := row.Scan(
		&i.ID,
		&i.Operation,
		&i.ExpenseID,
		&i.ExpenseDay,
		&i.ExpenseMonth,
		&i.ExpenseDescription,
		&i.ExpenseAmountCents,
		&i.ExpensePrimary,
		&i.ExpenseSecondary,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.NextRetryAt,
	)
	return i, err
}

const enqueueSync = `-- name: EnqueueSync :one

INSERT INTO sync_queue (operation, expense_id, status, created_at, updated_at)
VALUES ('sync', ?, 'pending', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, operation, expense_id, expense_day, expense_month, expense_description, expense_amount_cents, expense_primary, expense_secondary, status, attempts, max_attempts, last_error, created_at, updated_at, processed_at, next_retry_at
`

// Sync Queue queries
// Enqueues a sync operation for an expense.
func (q *Queries) EnqueueSync(ctx context.Context, expenseID int64) (SyncQueue, error) {
	row := q.db.QueryRowContext(ctx, enqueueSync, expenseID)
	var i SyncQueue
	err := row.Scan(
		&i.ID,
		&i.Operation,
		&i.ExpenseID,
		&i.ExpenseDay,
		&i.ExpenseMonth,
		&i.ExpenseDescription,
		&i.ExpenseAmountCents,
		&i.ExpensePrimary,
		&i.ExpenseSecondary,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.NextRetryAt,
	)
	return i, err
}

const getActiveRecurrentExpensesByDate = `-- name: GetActiveRecurrentExpensesByDate :many
SELECT id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, last_execution_date, created_at, updated_at FROM recurrent_expenses
WHERE is_active = 1
  AND start_date <= ?
  AND (end_date IS NULL OR end_date >= ?)
ORDER BY start_date DESC
`

type GetActiveRecurrentExpensesByDateParams struct {
	StartDate time.Time   `db:"start_date" json:"start_date"`
	EndDate   interface{} `db:"end_date" json:"end_date"`
}

func (q *Queries) GetActiveRecurrentExpensesByDate(ctx context.Context, arg GetActiveRecurrentExpensesByDateParams) ([]RecurrentExpense, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRecurrentExpensesByDate, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurrentExpense
	for rows.Next() {
		var i RecurrentExpense
		if err := rows.Scan(
			&i.ID,
			&i.StartDate,
			&i.EndDate,
			&i.RepetitionType,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.IsActive,
			&i.LastExecutionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveRecurrentExpensesForProcessing = `-- name: GetActiveRecurrentExpensesForProcessing :many
SELECT id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, last_execution_date, created_at, updated_at FROM recurrent_expenses
WHERE is_active = 1
  AND start_date <= ?
  AND (end_date IS NULL OR end_date >= ?)
ORDER BY start_date ASC
`

type GetActiveRecurrentExpensesForProcessingParams struct {
	StartDate time.Time   `db:"start_date" json:"start_date"`
	EndDate   interface{} `db:"end_date" json:"end_date"`
}

func (q *Queries) GetActiveRecurrentExpensesForProcessing(ctx context.Context, arg GetActiveRecurrentExpensesForProcessingParams) ([]RecurrentExpense, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRecurrentExpensesForProcessing, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurrentExpense
	for rows.Next() {
		var i RecurrentExpense
		if err := rows.Scan(
			&i.ID,
			&i.StartDate,
			&i.EndDate,
			&i.RepetitionType,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.IsActive,
			&i.LastExecutionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCategoriesWithSubs = `-- name: GetAllCategoriesWithSubs :many
SELECT pc.name as primary_name, sc.name as secondary_name
FROM primary_categories pc
LEFT JOIN secondary_categories sc ON sc.primary_category_id = pc.id
ORDER BY pc.name ASC, sc.name ASC
`

type GetAllCategoriesWithSubsRow struct {
	PrimaryName   string         `db:"primary_name" json:"primary_name"`
	SecondaryName sql.NullString `db:"secondary_name" json:"secondary_name"`
}

func (q *Queries) GetAllCategoriesWithSubs(ctx context.Context) ([]GetAllCategoriesWithSubsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCategoriesWithSubs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCategoriesWithSubsRow
	for rows.Next() {
		var i GetAllCategoriesWithSubsRow
		if err := rows.Scan(&i.PrimaryName, &i.SecondaryName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesOrderedByUsage = `-- name: GetCategoriesOrderedByUsage :many
SELECT
  pc.name as primary_name,
  sc.name as secondary_name,
  COALESCE(exp_count.cnt, 0) as usage_count
FROM primary_categories pc
LEFT JOIN secondary_categories sc ON sc.primary_category_id = pc.id
LEFT JOIN (
  SELECT primary_category, secondary_category, COUNT(*) as cnt
  FROM expenses
  GROUP BY primary_category, secondary_category
) exp_count ON exp_count.primary_category = pc.name AND exp_count.secondary_category = sc.name
ORDER BY
  COALESCE((SELECT SUM(cnt) FROM (SELECT COUNT(*) as cnt FROM expenses WHERE primary_category = pc.name GROUP BY primary_category)), 0) DESC,
  pc.name ASC,
  COALESCE(exp_count.cnt, 0) DESC,
  sc.name ASC
`

type GetCategoriesOrderedByUsageRow struct {
	PrimaryName   string         `db:"primary_name" json:"primary_name"`
	SecondaryName sql.NullString `db:"secondary_name" json:"secondary_name"`
	UsageCount    int64          `db:"usage_count" json:"usage_count"`
}

func (q *Queries) GetCategoriesOrderedByUsage(ctx context.Context) ([]GetCategoriesOrderedByUsageRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategoriesOrderedByUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoriesOrderedByUsageRow
	for rows.Next() {
		var i GetCategoriesOrderedByUsageRow
		if err := rows.Scan(&i.PrimaryName, &i.SecondaryName, &i.UsageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategorySums = `-- name: GetCategorySums :many
SELECT primary_category, CAST(SUM(amount_cents) AS INTEGER) as total_amount
FROM expenses
WHERE strftime('%Y', date) = printf('%04d', ?)
  AND strftime('%m', date) = printf('%02d', ?)
GROUP BY primary_category
ORDER BY total_amount DESC
`

type GetCategorySumsParams struct {
	PRINTF   interface{} `db:"PRINTF" json:"PRINTF"`
	PRINTF_2 interface{} `db:"PRINTF_2" json:"PRINTF_2"`
}

type GetCategorySumsRow struct {
	PrimaryCategory string `db:"primary_category" json:"primary_category"`
	TotalAmount     int64  `db:"total_amount" json:"total_amount"`
}

func (q *Queries) GetCategorySums(ctx context.Context, arg GetCategorySumsParams) ([]GetCategorySumsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategorySums, arg.PRINTF, arg.PRINTF_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategorySumsRow
	for rows.Next() {
		var i GetCategorySumsRow
		if err := rows.Scan(&i.PrimaryCategory, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpense = `-- name: GetExpense :one
SELECT id, date, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses WHERE id = ?
`

func (q *Queries) GetExpense(ctx context.Context, id int64) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpense, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const getExpensesByMonth = `-- name: GetExpensesByMonth :many
SELECT id, date, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses
WHERE strftime('%Y', date) = printf('%04d', ?)
  AND strftime('%m', date) = printf('%02d', ?)
ORDER BY date DESC, created_at DESC
`

type GetExpensesByMonthParams struct {
	PRINTF   interface{} `db:"PRINTF" json:"PRINTF"`
	PRINTF_2 interface{} `db:"PRINTF_2" json:"PRINTF_2"`
}

func (q *Queries) GetExpensesByMonth(ctx context.Context, arg GetExpensesByMonthParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByMonth, arg.PRINTF, arg.PRINTF_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.Version,
			&i.CreatedAt,
			&i.SyncedAt,
			&i.SyncStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncome = `-- name: GetIncome :one
SELECT id, date, description, amount_cents, category, version, created_at, synced_at, sync_status FROM incomes WHERE id = ?
`

func (q *Queries) GetIncome(ctx context.Context, id int64) (Income, error) {
	row := q.db.QueryRowContext(ctx, getIncome, id)
	var i Income
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Description,
		&i.AmountCents,
		&i.Category,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const getIncomeCategories = `-- name: GetIncomeCategories :many
SELECT name FROM income_categories
ORDER BY name ASC
`

func (q *Queries) GetIncomeCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getIncomeCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncomeCategorySums = `-- name: GetIncomeCategorySums :many
SELECT category, CAST(SUM(amount_cents) AS INTEGER) as total_amount
FROM incomes
WHERE strftime('%Y', date) = printf('%04d', ?)
  AND strftime('%m', date) = printf('%02d', ?)
GROUP BY category
ORDER BY total_amount DESC
`

type GetIncomeCategorySumsParams struct {
	PRINTF   interface{} `db:"PRINTF" json:"PRINTF"`
	PRINTF_2 interface{} `db:"PRINTF_2" json:"PRINTF_2"`
}

type GetIncomeCategorySumsRow struct {
	Category    string `db:"category" json:"category"`
	TotalAmount int64  `db:"total_amount" json:"total_amount"`
}

func (q *Queries) GetIncomeCategorySums(ctx context.Context, arg GetIncomeCategorySumsParams) ([]GetIncomeCategorySumsRow, error) {
	rows, err := q.db.QueryContext(ctx, getIncomeCategorySums, arg.PRINTF, arg.PRINTF_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIncomeCategorySumsRow
	for rows.Next() {
		var i GetIncomeCategorySumsRow
		if err := rows.Scan(&i.Category, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncomeMonthTotal = `-- name: GetIncomeMonthTotal :one
SELECT CAST(COALESCE(SUM(amount_cents), 0) AS INTEGER) as total
FROM incomes
WHERE strftime('%Y', date) = printf('%04d', ?)
  AND strftime('%m', date) = printf('%02d', ?)
`

type GetIncomeMonthTotalParams struct {
	PRINTF   interface{} `db:"PRINTF" json:"PRINTF"`
	PRINTF_2 interface{} `db:"PRINTF_2" json:"PRINTF_2"`
}

func (q *Queries) GetIncomeMonthTotal(ctx context.Context, arg GetIncomeMonthTotalParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getIncomeMonthTotal, arg.PRINTF, arg.PRINTF_2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getIncomesByMonth = `-- name: GetIncomesByMonth :many
SELECT id, date, description, amount_cents, category, version, created_at, synced_at, sync_status FROM incomes
WHERE strftime('%Y', date) = printf('%04d', ?)
  AND strftime('%m', date) = printf('%02d', ?)
ORDER BY date DESC, created_at DESC
`

type GetIncomesByMonthParams struct {
	PRINTF   interface{} `db:"PRINTF" json:"PRINTF"`
	PRINTF_2 interface{} `db:"PRINTF_2" json:"PRINTF_2"`
}

func (q *Queries) GetIncomesByMonth(ctx context.Context, arg GetIncomesByMonthParams) ([]Income, error) {
	rows, err := q.db.QueryContext(ctx, getIncomesByMonth, arg.PRINTF, arg.PRINTF_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Income
	for rows.Next() {
		var i Income
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Description,
			&i.AmountCents,
			&i.Category,
			&i.Version,
			&i.CreatedAt,
			&i.SyncedAt,
			&i.SyncStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTotal = `-- name: GetMonthTotal :one
SELECT CAST(COALESCE(SUM(amount_cents), 0) AS INTEGER) as total
FROM expenses
WHERE strftime('%Y', date) = printf('%04d', ?)
  AND strftime('%m', date) = printf('%02d', ?)
`

type GetMonthTotalParams struct {
	PRINTF   interface{} `db:"PRINTF" json:"PRINTF"`
	PRINTF_2 interface{} `db:"PRINTF_2" json:"PRINTF_2"`
}

func (q *Queries) GetMonthTotal(ctx context.Context, arg GetMonthTotalParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMonthTotal, arg.PRINTF, arg.PRINTF_2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getPendingSyncExpenses = `-- name: GetPendingSyncExpenses :many
SELECT id, version, created_at FROM expenses 
WHERE sync_status = 'pending'
ORDER BY created_at ASC
LIMIT ?
`

type GetPendingSyncExpensesRow struct {
	ID        int64        `db:"id" json:"id"`
	Version   int64        `db:"version" json:"version"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
}

func (q *Queries) GetPendingSyncExpenses(ctx context.Context, limit int64) ([]GetPendingSyncExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSyncExpenses, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingSyncExpensesRow
	for rows.Next() {
		var i GetPendingSyncExpensesRow
		if err := rows.Scan(&i.ID, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryCategories = `-- name: GetPrimaryCategories :many
SELECT name FROM primary_categories 
ORDER BY name ASC
`

// Primary Categories queries
func (q *Queries) GetPrimaryCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getPrimaryCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurrentExpenseByID = `-- name: GetRecurrentExpenseByID :one
SELECT id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, last_execution_date, created_at, updated_at FROM recurrent_expenses
WHERE id = ?
`

func (q *Queries) GetRecurrentExpenseByID(ctx context.Context, id int64) (RecurrentExpense, error) {
	row := q.db.QueryRowContext(ctx, getRecurrentExpenseByID, id)
	var i RecurrentExpense
	err := row.Scan(
		&i.ID,
		&i.StartDate,
		&i.EndDate,
		&i.RepetitionType,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.IsActive,
		&i.LastExecutionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecurrentExpenses = `-- name: GetRecurrentExpenses :many
SELECT id, start_date, end_date, repetition_type, description, amount_cents, primary_category, secondary_category, is_active, last_execution_date, created_at, updated_at FROM recurrent_expenses
WHERE is_active = 1
ORDER BY start_date DESC
`

func (q *Queries) GetRecurrentExpenses(ctx context.Context) ([]RecurrentExpense, error) {
	rows, err := q.db.QueryContext(ctx, getRecurrentExpenses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurrentExpense
	for rows.Next() {
		var i RecurrentExpense
		if err := rows.Scan(
			&i.ID,
			&i.StartDate,
			&i.EndDate,
			&i.RepetitionType,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.IsActive,
			&i.LastExecutionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecondariesByPrimary = `-- name: GetSecondariesByPrimary :many
SELECT sc.name FROM secondary_categories sc
JOIN primary_categories pc ON sc.primary_category_id = pc.id
WHERE pc.name = ?
ORDER BY sc.name ASC
`

func (q *Queries) GetSecondariesByPrimary(ctx context.Context, name string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSecondariesByPrimary, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecondaryCategories = `-- name: GetSecondaryCategories :many
SELECT name FROM secondary_categories 
ORDER BY name ASC
`

// Secondary Categories queries
func (q *Queries) GetSecondaryCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSecondaryCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSyncQueueItem = `-- name: GetSyncQueueItem :one
SELECT id, operation, expense_id, expense_day, expense_month, expense_description, expense_amount_cents, expense_primary, expense_secondary, status, attempts, max_attempts, last_error, created_at, updated_at, processed_at, next_retry_at FROM sync_queue WHERE id = ?
`

// Gets a single sync queue item by ID.
func (q *Queries) GetSyncQueueItem(ctx context.Context, id int64) (SyncQueue, error) {
	row := q.db.QueryRowContext(ctx, getSyncQueueItem, id)
	var i SyncQueue
	err := row.Scan(
		&i.ID,
		&i.Operation,
		&i.ExpenseID,
		&i.ExpenseDay,
		&i.ExpenseMonth,
		&i.ExpenseDescription,
		&i.ExpenseAmountCents,
		&i.ExpensePrimary,
		&i.ExpenseSecondary,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessedAt,
		&i.NextRetryAt,
	)
	return i, err
}

const getSyncQueueStats = `-- name: GetSyncQueueStats :one
SELECT
    CAST(SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) AS INTEGER) as pending_count,
    CAST(SUM(CASE WHEN status = 'processing' THEN 1 ELSE 0 END) AS INTEGER) as processing_count,
    CAST(SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS INTEGER) as completed_count,
    CAST(SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) AS INTEGER) as failed_count
FROM sync_queue
`

type GetSyncQueueStatsRow struct {
	PendingCount    int64 `db:"pending_count" json:"pending_count"`
	ProcessingCount int64 `db:"processing_count" json:"processing_count"`
	CompletedCount  int64 `db:"completed_count" json:"completed_count"`
	FailedCount     int64 `db:"failed_count" json:"failed_count"`
}

// Returns counts by status for monitoring.
func (q *Queries) GetSyncQueueStats(ctx context.Context) (GetSyncQueueStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSyncQueueStats)
	var i GetSyncQueueStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.ProcessingCount,
		&i.CompletedCount,
		&i.FailedCount,
	)
	return i, err
}

const hardDeleteExpense = `-- name: HardDeleteExpense :exec
DELETE FROM expenses 
WHERE id = ?
`

func (q *Queries) HardDeleteExpense(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, hardDeleteExpense, id)
	return err
}

const hardDeleteIncome = `-- name: HardDeleteIncome :exec
DELETE FROM incomes
WHERE id = ?
`

func (q *Queries) HardDeleteIncome(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, hardDeleteIncome, id)
	return err
}

const incrementSyncAttempt = `-- name: IncrementSyncAttempt :exec
UPDATE sync_queue
SET attempts = attempts + 1,
    last_error = ?,
    status = 'pending',
    next_retry_at = datetime(CURRENT_TIMESTAMP, '+' || (1 << attempts) || ' minutes'),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type IncrementSyncAttemptParams struct {
	LastError interface{} `db:"last_error" json:"last_error"`
	ID        int64       `db:"id" json:"id"`
}

// Increments attempt count and schedules next retry with exponential backoff.
func (q *Queries) IncrementSyncAttempt(ctx context.Context, arg IncrementSyncAttemptParams) error {
	_, err := q.db.ExecContext(ctx, incrementSyncAttempt, arg.LastError, arg.ID)
	return err
}

const listExpensesByDateRange = `-- name: ListExpensesByDateRange :many
SELECT id, date, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses
WHERE date >= ? AND date <= ?
ORDER BY date DESC, created_at DESC
`

type ListExpensesByDateRangeParams struct {
	Date   time.Time `db:"date" json:"date"`
	Date_2 time.Time `db:"date_2" json:"date_2"`
}

func (q *Queries) ListExpensesByDateRange(ctx context.Context, arg ListExpensesByDateRangeParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, listExpensesByDateRange, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.Version,
			&i.CreatedAt,
			&i.SyncedAt,
			&i.SyncStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markExpenseSyncError = `-- name: MarkExpenseSyncError :exec
UPDATE expenses 
SET sync_status = 'error'
WHERE id = ?
`

func (q *Queries) MarkExpenseSyncError(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSyncError, id)
	return err
}

const markExpenseSynced = `-- name: MarkExpenseSynced :exec
UPDATE expenses 
SET sync_status = 'synced', synced_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkExpenseSynced(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSynced, id)
	return err
}

const markSyncComplete = `-- name: MarkSyncComplete :exec
UPDATE sync_queue
SET status = 'completed',
    processed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

// Marks a sync queue item as successfully completed.
func (q *Queries) MarkSyncComplete(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markSyncComplete, id)
	return err
}

const markSyncFailed = `-- name: MarkSyncFailed :exec
UPDATE sync_queue
SET status = 'failed',
    last_error = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type MarkSyncFailedParams struct {
	LastError interface{} `db:"last_error" json:"last_error"`
	ID        int64       `db:"id" json:"id"`
}

// Marks a sync queue item as failed after max retries exceeded.
func (q *Queries) MarkSyncFailed(ctx context.Context, arg MarkSyncFailedParams) error {
	_, err := q.db.ExecContext(ctx, markSyncFailed, arg.LastError, arg.ID)
	return err
}

const markSyncProcessing = `-- name: MarkSyncProcessing :exec
UPDATE sync_queue
SET status = 'processing', updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

// Marks an item as being processed.
func (q *Queries) MarkSyncProcessing(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markSyncProcessing, id)
	return err
}

const refreshCategories = `-- name: RefreshCategories :exec
DELETE FROM secondary_categories
`

func (q *Queries) RefreshCategories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshCategories)
	return err
}

const refreshPrimaryCategories = `-- name: RefreshPrimaryCategories :exec
DELETE FROM primary_categories
`

func (q *Queries) RefreshPrimaryCategories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshPrimaryCategories)
	return err
}

const resetStaleProcessing = `-- name: ResetStaleProcessing :exec
UPDATE sync_queue
SET status = 'pending',
    updated_at = CURRENT_TIMESTAMP
WHERE status = 'processing'
  AND updated_at < datetime(CURRENT_TIMESTAMP, '-5 minutes')
`

// Resets items stuck in processing state (crash recovery).
func (q *Queries) ResetStaleProcessing(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetStaleProcessing)
	return err
}

const retryFailedSyncs = `-- name: RetryFailedSyncs :exec
UPDATE sync_queue
SET status = 'pending',
    attempts = 0,
    next_retry_at = NULL,
    last_error = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE status = 'failed'
`

// Resets failed items back to pending for manual retry.
func (q *Queries) RetryFailedSyncs(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, retryFailedSyncs)
	return err
}

const updateRecurrentExpense = `-- name: UpdateRecurrentExpense :exec
UPDATE recurrent_expenses
SET start_date = ?, 
    end_date = ?, 
    repetition_type = ?, 
    description = ?,
    amount_cents = ?, 
    primary_category = ?, 
    secondary_category = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateRecurrentExpenseParams struct {
	StartDate         time.Time   `db:"start_date" json:"start_date"`
	EndDate           interface{} `db:"end_date" json:"end_date"`
	RepetitionType    string      `db:"repetition_type" json:"repetition_type"`
	Description       string      `db:"description" json:"description"`
	AmountCents       int64       `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string      `db:"primary_category" json:"primary_category"`
	SecondaryCategory string      `db:"secondary_category" json:"secondary_category"`
	ID                int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateRecurrentExpense(ctx context.Context, arg UpdateRecurrentExpenseParams) error {
	_, err := q.db.ExecContext(ctx, updateRecurrentExpense,
		arg.StartDate,
		arg.EndDate,
		arg.RepetitionType,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
		arg.ID,
	)
	return err
}

const updateRecurrentLastExecution = `-- name: UpdateRecurrentLastExecution :exec
UPDATE recurrent_expenses
SET last_execution_date = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateRecurrentLastExecutionParams struct {
	LastExecutionDate interface{} `db:"last_execution_date" json:"last_execution_date"`
	ID                int64       `db:"id" json:"id"`
}

func (q *Queries) UpdateRecurrentLastExecution(ctx context.Context, arg UpdateRecurrentLastExecutionParams) error {
	_, err := q.db.ExecContext(ctx, updateRecurrentLastExecution, arg.LastExecutionDate, arg.ID)
	return err
}
