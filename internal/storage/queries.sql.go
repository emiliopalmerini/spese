// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package storage

import (
	"context"
	"database/sql"
)

const createExpense = `-- name: CreateExpense :one
INSERT INTO expenses (day, month, description, amount_cents, primary_category, secondary_category)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status
`

type CreateExpenseParams struct {
	Day               int64  `db:"day" json:"day"`
	Month             int64  `db:"month" json:"month"`
	Description       string `db:"description" json:"description"`
	AmountCents       int64  `db:"amount_cents" json:"amount_cents"`
	PrimaryCategory   string `db:"primary_category" json:"primary_category"`
	SecondaryCategory string `db:"secondary_category" json:"secondary_category"`
}

func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.Day,
		arg.Month,
		arg.Description,
		arg.AmountCents,
		arg.PrimaryCategory,
		arg.SecondaryCategory,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Day,
		&i.Month,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const createPrimaryCategory = `-- name: CreatePrimaryCategory :one
INSERT INTO primary_categories (name)
VALUES (?)
RETURNING id, name, created_at
`

func (q *Queries) CreatePrimaryCategory(ctx context.Context, name string) (PrimaryCategory, error) {
	row := q.db.QueryRowContext(ctx, createPrimaryCategory, name)
	var i PrimaryCategory
	err := row.Scan(&i.ID, &i.Name, &i.CreatedAt)
	return i, err
}

const createSecondaryCategory = `-- name: CreateSecondaryCategory :one
INSERT INTO secondary_categories (name, primary_category_id)
VALUES (?, ?)
RETURNING id, name, primary_category_id, created_at
`

type CreateSecondaryCategoryParams struct {
	Name              string `db:"name" json:"name"`
	PrimaryCategoryID int64  `db:"primary_category_id" json:"primary_category_id"`
}

func (q *Queries) CreateSecondaryCategory(ctx context.Context, arg CreateSecondaryCategoryParams) (SecondaryCategory, error) {
	row := q.db.QueryRowContext(ctx, createSecondaryCategory, arg.Name, arg.PrimaryCategoryID)
	var i SecondaryCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PrimaryCategoryID,
		&i.CreatedAt,
	)
	return i, err
}

const deletePrimaryCategory = `-- name: DeletePrimaryCategory :exec
DELETE FROM primary_categories WHERE name = ?
`

func (q *Queries) DeletePrimaryCategory(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deletePrimaryCategory, name)
	return err
}

const deleteSecondaryCategory = `-- name: DeleteSecondaryCategory :exec
DELETE FROM secondary_categories WHERE name = ?
`

func (q *Queries) DeleteSecondaryCategory(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteSecondaryCategory, name)
	return err
}

const getCategorySums = `-- name: GetCategorySums :many
SELECT primary_category, CAST(SUM(amount_cents) AS INTEGER) as total_amount
FROM expenses 
WHERE month = ?
GROUP BY primary_category
ORDER BY total_amount DESC
`

type GetCategorySumsRow struct {
	PrimaryCategory string `db:"primary_category" json:"primary_category"`
	TotalAmount     int64  `db:"total_amount" json:"total_amount"`
}

func (q *Queries) GetCategorySums(ctx context.Context, month int64) ([]GetCategorySumsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategorySums, month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategorySumsRow
	for rows.Next() {
		var i GetCategorySumsRow
		if err := rows.Scan(&i.PrimaryCategory, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpense = `-- name: GetExpense :one
SELECT id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses WHERE id = ?
`

func (q *Queries) GetExpense(ctx context.Context, id int64) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpense, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Day,
		&i.Month,
		&i.Description,
		&i.AmountCents,
		&i.PrimaryCategory,
		&i.SecondaryCategory,
		&i.Version,
		&i.CreatedAt,
		&i.SyncedAt,
		&i.SyncStatus,
	)
	return i, err
}

const getExpensesByMonth = `-- name: GetExpensesByMonth :many
SELECT id, day, month, description, amount_cents, primary_category, secondary_category, version, created_at, synced_at, sync_status FROM expenses 
WHERE month = ?
ORDER BY day DESC, created_at DESC
`

func (q *Queries) GetExpensesByMonth(ctx context.Context, month int64) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, getExpensesByMonth, month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Day,
			&i.Month,
			&i.Description,
			&i.AmountCents,
			&i.PrimaryCategory,
			&i.SecondaryCategory,
			&i.Version,
			&i.CreatedAt,
			&i.SyncedAt,
			&i.SyncStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthTotal = `-- name: GetMonthTotal :one
SELECT CAST(COALESCE(SUM(amount_cents), 0) AS INTEGER) as total
FROM expenses 
WHERE month = ?
`

func (q *Queries) GetMonthTotal(ctx context.Context, month int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMonthTotal, month)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getPendingSyncExpenses = `-- name: GetPendingSyncExpenses :many
SELECT id, version, created_at FROM expenses 
WHERE sync_status = 'pending'
ORDER BY created_at ASC
LIMIT ?
`

type GetPendingSyncExpensesRow struct {
	ID        int64        `db:"id" json:"id"`
	Version   int64        `db:"version" json:"version"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
}

func (q *Queries) GetPendingSyncExpenses(ctx context.Context, limit int64) ([]GetPendingSyncExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSyncExpenses, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingSyncExpensesRow
	for rows.Next() {
		var i GetPendingSyncExpensesRow
		if err := rows.Scan(&i.ID, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryCategories = `-- name: GetPrimaryCategories :many
SELECT name FROM primary_categories 
ORDER BY name ASC
`

// Primary Categories queries
func (q *Queries) GetPrimaryCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getPrimaryCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecondariesByPrimary = `-- name: GetSecondariesByPrimary :many
SELECT sc.name FROM secondary_categories sc
JOIN primary_categories pc ON sc.primary_category_id = pc.id
WHERE pc.name = ?
ORDER BY sc.name ASC
`

func (q *Queries) GetSecondariesByPrimary(ctx context.Context, name string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSecondariesByPrimary, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecondaryCategories = `-- name: GetSecondaryCategories :many
SELECT name FROM secondary_categories 
ORDER BY name ASC
`

// Secondary Categories queries
func (q *Queries) GetSecondaryCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSecondaryCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markExpenseSyncError = `-- name: MarkExpenseSyncError :exec
UPDATE expenses 
SET sync_status = 'error'
WHERE id = ?
`

func (q *Queries) MarkExpenseSyncError(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSyncError, id)
	return err
}

const markExpenseSynced = `-- name: MarkExpenseSynced :exec
UPDATE expenses 
SET sync_status = 'synced', synced_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkExpenseSynced(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markExpenseSynced, id)
	return err
}

const refreshCategories = `-- name: RefreshCategories :exec
DELETE FROM secondary_categories
`

func (q *Queries) RefreshCategories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshCategories)
	return err
}

const refreshPrimaryCategories = `-- name: RefreshPrimaryCategories :exec
DELETE FROM primary_categories
`

func (q *Queries) RefreshPrimaryCategories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, refreshPrimaryCategories)
	return err
}
